# 1.4b Computational Methods

## Thinking Abstractly and Visualisation

Abstraction is the process of removing unnecessary information from an idea until you are left with just the core concepts, then focusing on the core. This speeds up the work process, allowing the creator to ignore unnecessary information and details and instead creating a system that promotes a time efficient work environment. In my game, this means abstracting the core interactions and ideas from the ideas I have around second stage things, like the visuals or audio areas of the game- focusing solely on the code and what makes the game unique.&#x20;

Visualisation is the idea of seeing how something is going to happen before it happens. This relies on an understanding, in this case, of the code itself and the ecosystems I wish to imitate. I need to be able to visualise the interactions that will happen, the code that is needed to make those interactions occur and the way the player will see both things combined. This visualisation helps the developer save time on having to guess what will happen if they do x thing, as they have already envisioned a solution or a work around. This will save me time and relies on my understanding mainly of the interactions between the things I want to add and then the code that will be needed to bring that to life. As of right now I know the basics of the ecosystem I wish to implement but my weakness is my lack of understanding of how the code will look to make my ideas come true.

## Thinking Ahead

Thinking ahead is vital for coding in any circumstances, but it matters even more in the time constraints of this project. This means that as we have a limited time window, it is more important to not waste time- something thinking ahead is vita for. Rather than having to try out many different solutions and techniques, the developer can think ahead to the impact that change will have and use that to predict whether the addition is beneficial and worth the time demand.&#x20;

For example, as of now I can think ahead around my project over the topic of the taskbar. I can predict that when first implemented, it may not remove the task that is completed, or give any indication that a task hasn't been completed. This may lead to as taskbar that is too large as it doesn't remove any of the completed tasks. To counter this issue, I'm envisioning that I am going to need a system to detect when a task is done. This will then need to deliver the appropriate reward for the task, then follow this by removing itself from the list, maybe after a clear representation that the task is done.

This simple idea will save me the experimentation of building a taskbar, implementing it, moving on only to realise at the end of the project that the taskbar just infinitely increases in size. &#x20;

## Thinking Procedurally and Decomposition

The first process in coding is the decomposition of the main features, then the picking out of issues. By decomposing, the developer gets to think about the large, intimidating areas of a project in smaller, more reasonable chunks. This increases motivation as the developer sees that they are succeeding and making progress whilst simultaneously increasing productivity via compartmentalisation and ensuring that any issues are contained and quickly found to be fixed. Thinking procedurally implies taking the decomposed points and organising them correctly, thinking of ways the code solve the problem. The developer must see the issues that will arise if something is added before it happens in a run through sort of system. If they are working on the middle of a project and want to change something in the start of their project, procedural thinking would allow them to realise that changing that one thing will create a series of issues, chaining back to the end of the project.&#x20;

## Thinking Logically

## Thinking Concurrently

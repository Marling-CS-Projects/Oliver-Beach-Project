# 1.4b Computational Methods

## Thinking Abstractly and Visualisation

Abstraction is the process of removing unnecessary information from an idea until you are left with just the core concepts, then focusing on that. All the details that do not contribute to the essential characteristics of the problem are emitted. You seperate the logical and physical aspects of a problem. This speeds up the work process, allowing the creator to ignore unnecessary information and details and instead creating a system that promotes a time efficient work environment. In my game, this means abstracting the core interactions and ideas from the ideas I have around second stage things, like the visuals or audio areas of the game- focusing solely on the key components. I will seperate the game into sections, some of which will include: entity collisions, pause menu, taskbar, entity movement, age stages and a time / date setting. Abstraction allows me to see the main components of the game with no excess detail that will lead to me coding the project in less time and having a more completed game overall.&#x20;

Visualisation is the idea of seeing how something is going to happen before it happens. This relies on an understanding, in this case, of the code itself and the ecosystems I wish to imitate. I need to be able to visualise the interactions that will happen, the code that is needed to make those interactions occur and the way the player will see both things combined. This visualisation helps the developer save time on having to guess what will happen if they do x thing, as they have already envisioned a solution or a work around. This will save me time and relies on my understanding mainly of the interactions between the things I want to add and then the code that will be needed to bring that to life. As of right now I know the basics of the ecosystem I wish to implement but my weakness is my lack of understanding of how the code will look to make my ideas come true.

## Thinking Ahead

Thinking ahead is vital for coding in any circumstances, but it matters even more in the time constraints of this project. This means that as we have a limited time window, it is more important to not waste time- something thinking ahead is vital for. Rather than having to try out many different solutions and techniques, the developer can think ahead to the impact that change will have and use that to predict whether the addition is beneficial and worth the time demand. The two major challenges in producing a solution are ensuring the code is correct to any given inputs and to ensure that it is efficient.&#x20;

For example, as of now I can think ahead around my project over the topic of the taskbar. I can predict that when first implemented, it may not remove the task that is completed, or give any indication that a task hasn't been completed. This may lead to a taskbar that is too large as it doesn't remove any of the completed tasks. To counter this issue, I'm envisioning that I am going to need a system to detect when a task is done. This will then need to deliver the appropriate reward for the task, then follow this by removing itself from the list, maybe after a clear representation that the task is done.

This simple idea will save me the experimentation of building a taskbar, implementing it, moving on only to realise at the end of the project that the taskbar just infinitely increases in size.  The developer builds a pseudo code example of the code and this allows them to see what will happen and how it will work- it doesn't need to be syntactically correct but it does need to work.&#x20;

Another way that I could save time is by my use or creation of coding libraries. If I created a library for entity collisions then I would spend time once creating it and every time after that I would save time by being able to just paste that library into the new animal or thing and it would allow me to save lots of time.&#x20;

## Thinking Procedurally and Decomposition

The first process in coding is the decomposition of the main features, then the picking out of issues. By decomposing, the developer gets to think about the large, intimidating areas of a project in smaller, more reasonable chunks. This increases motivation as the developer sees that they are succeeding and making progress whilst simultaneously increasing productivity via compartmentalisation and ensuring that any issues are contained and quickly found to be fixed. Thinking procedurally implies taking the decomposed points and organising them correctly, thinking of ways the code solve the problem. The developer must see the issues that will arise if something is added before it happens in a run through sort of system. If they are working on the middle of a project and want to change something in the start of their project, procedural thinking would allow them to realise that changing that one thing will create a series of issues, chaining back to the end of the project. [https://computersciencewiki.org/index.php/Procedural\_thinking](https://computersciencewiki.org/index.php/Procedural\_thinking)

## Thinking Logically

## Thinking Concurrently

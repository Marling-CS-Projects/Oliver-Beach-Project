# 1.4b Computational Methods

## Thinking Abstractly and Visualisation

Abstraction is the process of removing unnecessary information from an idea until you are left with just the core concepts, then focussing on the core. This speeds up the work process, allowing the creator to ignore unnecessary information and details and instead creating a system that promotes a time efficient work environment. In my game, this means abstracting the core interactions and ideas from the ideas I have around second stage things, like the visuals or audio areas of the game- focussing solely on the code and what makes the game unique.&#x20;

Visualisation is the idea of seeing how something is going to happen before it happens. This relies on an understanding, in this case, of the code itself and the ecosystems I wish to imitate. I need to be able to visualise the interactions that will happen, the code that is needed to make those interactions occur and the way the player will see both things combined. This visualisation helps the developer save time on having to guess what will happen if they do x thing, as they have already envisioned a solution or a work around. This will save me time and relies on my understanding mainly of the interactions between the things I want to add and then the code that will be needed to bring that to life. As of right now I know the basics of the ecosystem I wish to implement but my weakness is my lack of understanding of how the code will look to make my ideas come true.

## Thinking Ahead

Thinking ahead is vital for coding in any circumstances, but it matters even more in the time constraints of this project. This means that as we have a limited time window, it is more important to not waste time- something thinking ahead is vita for. Rather than having to try out many different solutions and techniques, the developer can think ahead to the impact that change will have and use that to predict whether the addition is beneficial and worth the time demand.&#x20;

For example, as of now I can think ahead around my project over the topic of the taskbar. I can predict that when first implemented, it may not remove the task that is completed, or give any indication that a task hasn't been completed. This may lead to as taskbar that is too large as it doesn't remove any of the completed tasks. To counter this issue, I'm envisioning that I am going to need a system to detect when a task is done. This will then need to deliver the appropriate reward for the task, then follow this by removing itself from the list, maybe after a clear representation that the task is done.

This simple idea will save me the experimentation of building a taskbar, implementing it, moving on only to realise at the end of the project that the taskbar just infinitely increases in size. &#x20;

## Thinking Procedurally and Decomposition

The first process in coding is the decomposition of the main features, then the picking out of issues. Thinking procedurally implies taking the decomposed points and organising them correctly, thinking of ways the code solve the problem.&#x20;

## Thinking Logically

## Thinking Concurrently
